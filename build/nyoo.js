// Generated by CoffeeScript 1.9.3

/*! Nyoo 0.0.3 //// MIT Licence //// http://nyoo.richplastow.com/ */

(function() {
  var Main, brittlize, parseMethodSignature, parsePropSignature, ª, ªA, ªB, ªC, ªE, ªF, ªN, ªO, ªR, ªS, ªU, ªV, ªX, ªex, ªhas, ªredefine, ªtype, ªuid,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ªC = 'Nyoo';

  ªV = '0.0.3';

  ªA = 'array';

  ªB = 'boolean';

  ªE = 'error';

  ªF = 'function';

  ªN = 'number';

  ªO = 'object';

  ªR = 'regexp';

  ªS = 'string';

  ªU = 'undefined';

  ªX = 'null';

  ª = console.log.bind(console);

  ªex = function(x, a, b) {
    var pos;
    if (-1 === (pos = a.indexOf(x))) {
      return x;
    } else {
      return b.charAt(pos);
    }
  };

  ªhas = function(h, n, t, f) {
    if (t == null) {
      t = true;
    }
    if (f == null) {
      f = false;
    }
    if (-1 !== h.indexOf(n)) {
      return t;
    } else {
      return f;
    }
  };

  ªtype = function(x) {
    return {}.toString.call(x).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
  };

  ªuid = function(p) {
    return p + '_' + (Math.random() + '1111111111111111').slice(2, 18);
  };

  ªredefine = function(obj, name, value, kind) {
    switch (kind) {
      case 'constant':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: true
        });
      case 'private':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: false
        });
    }
  };

  Main = (function() {
    Main.prototype.C = ªC;

    Main.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Main(config) {
      if (config == null) {
        config = {};
      }
      this.classes = {};
    }

    Main.prototype.add = function(Orig, name) {
      var Brittle;
      if (ªF !== typeof Orig) {
        throw new Error("`Orig` is type " + (ªtype(Orig)) + ", not function");
      }
      if (ªU !== typeof name) {
        if (ªS !== typeof name) {
          throw new Error("`name` is type " + (ªtype(name)) + ", not string");
        }
        if (!/^[A-Z][_0-9A-Za-z]{0,23}$/.test(name)) {
          throw new Error("`name` fails /^[A-Z][_0-9A-Za-z]{0,23}$/");
        }
      } else {
        if (ªS !== ªtype(Orig.prototype.C)) {
          throw new Error("`Orig::C` is type " + (ªtype(Orig.prototype.C)) + ", not string");
        }
        if (!/^[A-Z][_0-9A-Za-z]{0,23}$/.test(Orig.prototype.C)) {
          throw new Error("`Orig::C` fails /^[A-Z][_0-9A-Za-z]{0,23}$/");
        }
        name = Orig.prototype.C;
      }
      Brittle = brittlize(Orig);
      this[name] = function() {
        var inst;
        inst = new Brittle;
        Object.seal(inst);
        return inst;
      };
      this.classes[name] = Brittle;
      return this;
    };

    return Main;

  })();

  brittlize = function(Orig) {
    var Brittle, fn, fn1, init, key, memName, memType, memValue, method, methods, name, props, ref, ref1, ref2, signature, type, val;
    props = {};
    methods = {};
    ref = Orig.prototype;
    for (key in ref) {
      val = ref[key];
      if ('_public' === key.slice(-7)) {
        memName = key.slice(0, -7);
        memValue = Orig.prototype[memName];
        memType = ªtype(memValue);
        if (ªU === memType) {
          throw new Error("No such member as " + memName);
        }
        if (ªF === memType) {
          methods[memName] = parseMethodSignature(val, memName, memValue);
        } else {
          props[memName] = parsePropSignature(val, memName, memValue, memType);
        }
      }
    }
    Brittle = (function(superClass) {
      extend(_Class, superClass);

      function _Class() {
        var init, name, ref1, type;
        for (name in props) {
          ref1 = props[name], type = ref1[0], init = ref1[1];
          this[name + '_value'] = init;
        }
        _Class.__super__.constructor.call(this);
      }

      return _Class;

    })(Orig);
    fn = function(name, type, init) {
      return Object.defineProperty(Brittle.prototype, name, {
        get: function() {
          return this[name + '_value'];
        },
        set: function(v) {
          return this[name + '_value'] = v;
        }
      });
    };
    for (name in props) {
      ref1 = props[name], type = ref1[0], init = ref1[1];
      fn(name, type, init);
    }
    fn1 = function(name, signature, method) {
      return Brittle.prototype[name] = function() {
        return method.apply(this, arguments);
      };
    };
    for (name in methods) {
      ref2 = methods[name], signature = ref2[0], method = ref2[1];
      fn1(name, signature, method);
    }
    return Brittle;
  };

  parsePropSignature = function(signature, memName, memValue, memType) {
    var i, len, match, memTypeOk, type, types;
    if (ªS !== typeof signature) {
      throw new Error("`signature` is type " + (ªtype(signature)) + ", not string");
    }
    match = signature.match(/^<([|A-Za-z0-9]{1,40})>\s+(.{1,40})$/);
    if (null === match) {
      throw new Error("`signature` is not valid");
    }
    types = match[1].split('|');
    memTypeOk = false;
    for (i = 0, len = types.length; i < len; i++) {
      type = types[i];
      if (type === memType) {
        memTypeOk = true;
        break;
      }
    }
    if (!memTypeOk) {
      throw new Error(memName + " is type " + memType + ", which fails " + types);
    }
    return [types, memValue];
  };

  parseMethodSignature = function(signature, memName, memValue) {
    return [[[false, ['string', 'number']], [true, ['string']]], memValue];
  };

  if (ªF === typeof define && define.amd) {
    define(function() {
      return Main;
    });
  } else if (ªO === typeof module && module && module.exports) {
    module.exports = Main;
  } else {
    this[ªC] = Main;
  }

}).call(this);
